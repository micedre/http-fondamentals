---
title: "Chapter 6: Authentication"
subtitle: "Securing HTTP Requests and APIs"
---

# Introduction to HTTP Authentication

Authentication verifies the identity of a client making requests. HTTP provides several mechanisms for authentication, each with different security characteristics and use cases.

## Why Authentication?

- **Identify users**: Know who is making requests

- **Identify users**: Know who is making requests
- **Authorize access**: Control what users can do
- **Track usage**: Monitor API consumption
- **Prevent abuse**: Protect against unauthorized access

## The Authorization Header

Most authentication schemes use the `Authorization` header:

```
Authorization: <scheme> <credentials>
```

Common schemes:
- `Basic`
- `Bearer`
- `Digest`
- `API-Key` (non-standard)

```{mermaid}
graph TD
    A[HTTP Authentication] --> B[Authorization Header]
    B --> C[Basic Auth]
    B --> D[Bearer Token]
    B --> E[Digest Auth]
    B --> F[API Key]

    C --> G[Base64 encoded<br/>username:password]
    D --> H[Token string<br/>JWT, OAuth token]
    E --> I[MD5 hash<br/>challenge-response]
    F --> J[API key string<br/>custom header]

    style C fill:#ffccbc
    style D fill:#c8e6c9
    style E fill:#fff9c4
    style F fill:#bbdefb
```

## Basic Authentication

Basic Auth sends username and password encoded in Base64.

Basic Auth sends username and password encoded in Base64.

### Basic Auth Format

```
Authorization: Basic base64(username:password)
```

```{mermaid}
sequenceDiagram
    participant Client
    participant Server

    Client->>Server: GET /protected
    Server->>Client: 401 Unauthorized<br/>WWW-Authenticate: Basic realm="API"

    Note over Client: User provides<br/>username & password

    Client->>Client: Encode "user:pass"<br/>to Base64

    Client->>Server: GET /protected<br/>Authorization: Basic dXNlcjpwYXNz

    alt Valid Credentials
        Server->>Client: 200 OK<br/>[Protected Resource]
    else Invalid Credentials
        Server->>Client: 401 Unauthorized
    end
```

### Basic Auth Example

```{hurl}
#| echo: true
#| output: true

GET https://httpbin.io/basic-auth/alice/secret123
Authorization: Basic YWxpY2U6c2VjcmV0MTIz
```

The credential `YWxpY2U6c2VjcmV0MTIz` is Base64 encoding of `alice:secret123`.

### Basic Auth with Different Credentials

```{hurl}
#| echo: true
#| output: true

# Correct credentials
GET https://httpbin.io/basic-auth/user/pass
Authorization: Basic dXNlcjpwYXNz
```

### Failed Basic Auth

```{hurl}
#| echo: true
#| output: true

# Wrong credentials - returns 401
GET https://httpbin.io/basic-auth/alice/secret123
Authorization: Basic d3JvbmdjcmVkcw==
```

### Basic Auth Security Concerns

- Credentials are only Base64 encoded (NOT encrypted)
- Easily decoded: `echo "YWxpY2U6c2VjcmV0MTIz" | base64 -d` â†’ `alice:secret123`
- **MUST use HTTPS** to protect credentials in transit
- Password sent with every request

### When to Use Basic Auth

- Internal APIs over HTTPS
- Simple authentication needs
- Development and testing
- Legacy system compatibility

## Bearer Token Authentication

Bearer tokens are opaque strings that represent authorization.

Bearer tokens are opaque strings that represent authorization.

### Bearer Token Format

```
Authorization: Bearer <token>
```

### Bearer Token Example

```{hurl}
#| echo: true
#| output: true

GET https://httpbin.io/bearer
Authorization: Bearer mySecretToken123456789
```

### Bearer Token with JWT

```{hurl}
#| echo: true
#| output: true

GET https://httpbin.io/bearer
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkFsaWNlIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
```

### JWT Structure

JWTs (JSON Web Tokens) have three parts separated by dots:

```
header.payload.signature
```

Example decoded JWT:
```json
// Header
{
  "alg": "HS256",
  "typ": "JWT"
}

// Payload
{
  "sub": "1234567890",
  "name": "Alice",
  "iat": 1516239022,
  "exp": 1516242622
}
```

### Bearer Token Best Practices

- Store securely (not in code)
- Use short expiration times
- Implement token refresh mechanism
- Revoke tokens when needed
- Always use HTTPS

## API Key Authentication

API keys are similar to bearer tokens but often passed in different ways.

API keys are similar to bearer tokens but often passed in different ways.

### API Key in Header

```{hurl}
#| echo: true
#| output: true

GET https://httpbin.io/headers
X-API-Key: sk_live_1234567890abcdef
```

### API Key with Custom Header Name

```{hurl}
#| echo: true
#| output: true

GET https://httpbin.io/headers
X-Custom-Auth: api-key-here
API-Token: another-key-format
```

### API Key in Query Parameter

```{hurl}
#| echo: true
#| output: true

GET https://httpbin.io/get?api_key=sk_test_abcdefghijk&user=alice
```

**Warning**: Query parameters appear in logs, so this is less secure!

### API Key Best Practices

- Use header over query parameter
- Implement rate limiting
- Support key rotation
- Log key usage
- Provide key management UI

## Multiple Authentication Methods

Some APIs support multiple authentication schemes:

Some APIs support multiple authentication schemes:

```{hurl}
#| echo: true
#| output: true

# Try Bearer token first
GET https://httpbin.io/headers
Authorization: Bearer token123
X-API-Key: fallback-key-456
```

## Authentication Flow Examples

### Login to Get Token

```{hurl}
#| echo: true
#| output: true

# Step 1: Login with credentials
POST https://httpbin.io/post
Content-Type: application/json

{
  "username": "alice",
  "password": "secret123"
}
```

In a real API, this would return a token:
```json
{
  "access_token": "eyJhbGciOiJIUzI1NiIs...",
  "token_type": "Bearer",
  "expires_in": 3600
}
```

### Use Token for Authenticated Request

```{hurl}
#| echo: true
#| output: true

# Step 2: Use the token
GET https://httpbin.io/bearer
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9
```

## OAuth 2.0 Concepts

OAuth 2.0 is a widely-used authorization framework.

### OAuth 2.0 Flow

1. **Authorization**: User grants permission
2. **Token Exchange**: App receives access token
3. **API Access**: App uses token for requests

```{mermaid}
sequenceDiagram
    participant User
    participant App as Client App
    participant Auth as Auth Server
    participant API as Resource Server

    User->>App: 1. Click "Login with OAuth"
    App->>Auth: 2. Authorization Request<br/>(redirect user)
    Auth->>User: 3. Login & Consent Screen
    User->>Auth: 4. Approve Access
    Auth->>App: 5. Authorization Code
    App->>Auth: 6. Exchange Code for Token<br/>(+ client credentials)
    Auth->>App: 7. Access Token + Refresh Token
    App->>API: 8. API Request<br/>Authorization: Bearer {token}
    API->>App: 9. Protected Resource
```

### OAuth Bearer Token

```{hurl}
#| echo: true
#| output: true

GET https://httpbin.io/bearer
Authorization: Bearer oauth2_access_token_here
```

### OAuth Token Types

- **Access Token**: Short-lived, for API access
- **Refresh Token**: Long-lived, to get new access tokens
- **ID Token**: Contains user information (OpenID Connect)

## Digest Authentication

More secure than Basic Auth, uses MD5 hashing.

More secure than Basic Auth, uses MD5 hashing.

### Digest Auth Challenge

```{hurl}
#| echo: true
#| output: true

# Server challenges with 401 and WWW-Authenticate header
GET https://httpbin.io/digest-auth/auth/user/pass
```

### Digest Auth Response

```{hurl}
#| echo: true
#| output: true

# Client responds with Authorization header containing hash
GET https://httpbin.io/digest-auth/auth/user/pass
Authorization: Digest username="user", realm="auth", nonce="dcd98b7102dd2f0e8b11d0f600bfb0c093", uri="/digest-auth/auth/user/pass", response="6629fae49393a05397450978507c4ef1"
```

Note: Hurl may handle digest auth automatically if supported.

## Hidden Basic Auth (Legacy)

Some old systems use URL-embedded credentials (NOT recommended):

Some old systems use URL-embedded credentials (NOT recommended):

```
https://username:password@api.example.com/endpoint
```

Example:
```{hurl}
#| echo: true
#| output: true

# This would work but is INSECURE
GET https://httpbin.io/basic-auth/user/pass
Authorization: Basic dXNlcjpwYXNz
```

**Never use this pattern** - credentials appear in logs and browser history.

## Session-Based Authentication

Common in web applications with cookies.

Common in web applications with cookies.

### Setting Session Cookie

```{hurl}
#| echo: true
#| output: true

# Login endpoint sets cookie
GET https://httpbin.io/cookies/set?session=abc123xyz&user=alice
```

### Using Session Cookie

```{hurl}
#| echo: true
#| output: true

# Subsequent requests include cookie
GET https://httpbin.io/cookies
Cookie: session=abc123xyz; user=alice
```

### Cookie Attributes

Cookies can have attributes for security:
- `HttpOnly`: Not accessible via JavaScript
- `Secure`: Only sent over HTTPS
- `SameSite`: CSRF protection
- `Max-Age`: Expiration time

## Multi-Factor Authentication (MFA)

APIs may require additional verification:

APIs may require additional verification:

```{hurl}
#| echo: true
#| output: true

# Send MFA code along with credentials
POST https://httpbin.io/post
Content-Type: application/json

{
  "username": "alice",
  "password": "secret123",
  "mfa_code": "123456"
}
```

## Rate Limiting and Authentication

Authenticated requests often have higher rate limits:

Authenticated requests often have higher rate limits:

```{hurl}
#| echo: true
#| output: true

# Unauthenticated: 60 requests/hour
GET https://httpbin.io/get
```

```{hurl}
#| echo: true
#| output: true

# Authenticated: 5000 requests/hour
GET https://httpbin.io/get
Authorization: Bearer token123
```

Look for rate limit headers in responses:
- `X-RateLimit-Limit`
- `X-RateLimit-Remaining`
- `X-RateLimit-Reset`

## Security Best Practices

### DO

1. **Always use HTTPS** for authenticated requests
2. **Store credentials securely** (environment variables, vaults)
3. **Implement token expiration**
4. **Use appropriate auth for use case**
5. **Log authentication attempts**
6. **Implement rate limiting**
7. **Support credential rotation**
8. **Use secure password policies**

### DON'T

1. **Don't store credentials in code**
2. **Don't log sensitive data**
3. **Don't send credentials in URLs**
4. **Don't use Basic Auth without HTTPS**
5. **Don't reuse tokens across services**
6. **Don't share API keys**
7. **Don't use weak passwords**
8. **Don't ignore certificate validation**

## Testing Authentication

### Test Valid Credentials

```{hurl}
#| echo: true
#| output: true

GET https://httpbin.io/basic-auth/testuser/testpass
Authorization: Basic dGVzdHVzZXI6dGVzdHBhc3M=
```

### Test Invalid Credentials

```{hurl}
#| echo: true
#| output: true

GET https://httpbin.io/basic-auth/testuser/testpass
Authorization: Basic d3JvbmdjcmVkcw==
```

### Test Missing Authentication

```{hurl}
#| echo: true
#| output: true

GET https://httpbin.io/basic-auth/testuser/testpass
```

### Test Expired Token

In real APIs, you'd test with an expired token and expect 401.

## Common Authentication Errors

### 401 Unauthorized

Missing or invalid authentication:

```{hurl}
#| echo: true
#| output: true

GET https://httpbin.io/bearer
# No Authorization header = 401
```

### 403 Forbidden

Authenticated but not authorized:

```{hurl}
#| echo: true
#| output: true

GET https://httpbin.io/status/403
Authorization: Bearer valid-token-insufficient-permissions
```

### 429 Too Many Requests

Rate limit exceeded:

```{hurl}
#| echo: true
#| output: true

GET https://httpbin.io/status/429
Authorization: Bearer token-over-rate-limit
```

## Authentication Comparison

| Scheme | Security | Complexity | Use Case |
|--------|----------|------------|----------|
| Basic | Low (needs HTTPS) | Very Simple | Internal APIs, simple auth |
| Bearer | Medium-High | Simple | Modern APIs, SPAs |
| API Key | Medium | Simple | Service-to-service, webhooks |
| OAuth 2.0 | High | Complex | Third-party integrations |
| Digest | Medium | Medium | Legacy systems |
| Session | Medium | Medium | Web applications |

## Real-World Authentication Example

```{hurl}
#| echo: true
#| output: true

# Complete authenticated API interaction

# 1. Login
POST https://httpbin.io/post
Content-Type: application/json

{
  "username": "alice@example.com",
  "password": "SecureP@ssw0rd"
}
```

```{hurl}
#| echo: true
#| output: true

# 2. Use token for authenticated request
GET https://httpbin.io/bearer
Authorization: Bearer returned-access-token-here
```

```{hurl}
#| echo: true
#| output: true

# 3. Create resource with authentication
POST https://httpbin.io/post
Authorization: Bearer returned-access-token-here
Content-Type: application/json

{
  "title": "New Resource",
  "description": "Created with authenticated request"
}
```

```{hurl}
#| echo: true
#| output: true

# 4. Refresh token before expiration
POST https://httpbin.io/post
Content-Type: application/json

{
  "grant_type": "refresh_token",
  "refresh_token": "refresh-token-here"
}
```

## Practice Exercises

Try these on your own:

1. Send a Basic Auth request with different credentials
2. Create a Bearer token request with a mock JWT
3. Send an API key in both header and query parameter
4. Test authentication failure scenarios (wrong password, missing header)
5. Combine authentication with other headers (Accept, Content-Type)

## Key Takeaways

- **Basic Auth**: Simple but requires HTTPS, sends credentials with every request
- **Bearer Token**: Modern standard, used with JWT and OAuth
- **API Key**: Simple, good for service-to-service auth
- **Always use HTTPS**: Never send credentials over HTTP
- **Token expiration**: Implement short-lived tokens with refresh mechanism
- **Error handling**: Return appropriate status codes (401, 403)
- **Security first**: Store credentials securely, implement rate limiting

## Next Steps

Now that you understand authentication, let's explore advanced HTTP topics including CORS, caching, and HTTP/2 in [Chapter 7: Advanced Topics](07-advanced.qmd).

---

## RFC References

This chapter covers concepts from the following RFCs:

::: {.callout-note icon=false}
### HTTP Authentication Framework

- **[RFC 9110](https://www.rfc-editor.org/rfc/rfc9110.html)** - HTTP Semantics
  - Section 11: [HTTP Authentication](https://www.rfc-editor.org/rfc/rfc9110.html#section-11)
  - Section 11.3: [Authentication Scheme Registry](https://www.rfc-editor.org/rfc/rfc9110.html#section-11.3)
  - Section 11.4: [Credentials](https://www.rfc-editor.org/rfc/rfc9110.html#credentials)
  - Section 11.5: [Establishing a Protection Space](https://www.rfc-editor.org/rfc/rfc9110.html#protection.space)
  - Section 11.6: [Authorization](https://www.rfc-editor.org/rfc/rfc9110.html#field.authorization)
  - Section 11.6.1: [WWW-Authenticate](https://www.rfc-editor.org/rfc/rfc9110.html#field.www-authenticate)

### Authentication Schemes

- **[RFC 7617](https://www.rfc-editor.org/rfc/rfc7617.html)** - Basic Authentication Scheme
- **[RFC 7616](https://www.rfc-editor.org/rfc/rfc7616.html)** - Digest Access Authentication

### OAuth and Tokens

- **[RFC 6750](https://www.rfc-editor.org/rfc/rfc6750.html)** - OAuth 2.0 Bearer Token Usage
- **[RFC 6749](https://www.rfc-editor.org/rfc/rfc6749.html)** - OAuth 2.0 Authorization Framework
- **[RFC 7519](https://www.rfc-editor.org/rfc/rfc7519.html)** - JSON Web Token (JWT)

### Session Management

- **[RFC 6265](https://www.rfc-editor.org/rfc/rfc6265.html)** - HTTP State Management (Cookies)
:::
