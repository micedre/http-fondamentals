---
title: "Chapter 1: HTTP Basics"
subtitle: "Understanding the Foundation of Web Communication"
---

# Introduction to HTTP

HTTP (Hypertext Transfer Protocol) is an application-layer protocol for transmitting hypermedia documents, such as HTML. It was designed for communication between web browsers and web servers, but it can also be used for other purposes.

## What is HTTP?

HTTP is:

- **Stateless**: Each request is independent; the server doesn't retain information between requests
- **Text-based**: HTTP messages are human-readable (though the body can be binary)
- **Client-Server**: Follows a request-response pattern
- **Application Layer**: Operates at Layer 7 of the OSI model

## The HTTP Request-Response Cycle

Every HTTP interaction follows this pattern:

1. **Client** sends a request to the server
2. **Server** processes the request
3. **Server** sends a response back to the client

```{mermaid}
sequenceDiagram
    participant Client
    participant Server
    Client->>Server: HTTP Request
    Note over Server: Process request
    Server->>Client: HTTP Response
```

Let's see this in action:

```{hurl}
#| echo: true
#| output: true

GET https://httpbin.io/get
```

## Anatomy of a URL

A URL (Uniform Resource Locator) identifies the location of a resource. Let's break down its components:

```
https://httpbin.io:443/get?name=value#section
└─┬─┘  └────┬────┘ └┬┘ └┬┘ └────┬────┘ └──┬──┘
  │         │        │   │       │          │
scheme   hostname  port path   query    fragment
```

```{mermaid}
graph LR
    A[Complete URL] --> B[Scheme: https]
    A --> C[Hostname: httpbin.io]
    A --> D[Port: 443]
    A --> E[Path: /get]
    A --> F[Query: ?name=value]
    A --> G[Fragment: #section]

    style A fill:#e1f5ff
    style B fill:#fff4e1
    style C fill:#fff4e1
    style D fill:#fff4e1
    style E fill:#fff4e1
    style F fill:#fff4e1
    style G fill:#fff4e1
```

- **Scheme**: Protocol to use (http, https)
- **Hostname**: Domain name or IP address
- **Port**: Optional (default: 80 for HTTP, 443 for HTTPS)
- **Path**: Resource location on the server
- **Query**: Optional parameters as key-value pairs
- **Fragment**: Optional reference to a specific part (not sent to server)

### URL Examples with Queries

```{hurl}
#| echo: true
#| output: true

GET https://httpbin.io/get?name=Alice&age=30&city=Paris
```

Notice in the response how the query parameters are parsed into the `args` object.

## HTTP Versions

HTTP has evolved over time:

- **HTTP/0.9** (1991): Single-line protocol, only GET method
- **HTTP/1.0** (1996): Added headers, status codes, and more methods
- **HTTP/1.1** (1997): Persistent connections, chunked transfers, host header
- **HTTP/2** (2015): Binary protocol, multiplexing, server push
- **HTTP/3** (2022): Based on QUIC, improved performance over UDP

Most modern applications use HTTP/1.1 or HTTP/2, with HTTP/3 gaining adoption.

## Structure of an HTTP Request

An HTTP request consists of:

1. **Request Line**: Method, URL path, and HTTP version
2. **Headers**: Metadata about the request
3. **Empty Line**: Separates headers from body
4. **Body**: Optional data payload

Example structure:
```
GET /users/123 HTTP/1.1
Host: api.example.com
User-Agent: MyClient/1.0
Accept: application/json

```

Let's examine a real request:

```{hurl}
#| echo: true
#| output: true

GET https://httpbin.io/headers
User-Agent: HTTP-Training-Client/1.0
Accept: application/json
```

## Structure of an HTTP Response

An HTTP response consists of:

1. **Status Line**: HTTP version, status code, and reason phrase
2. **Headers**: Metadata about the response
3. **Empty Line**: Separates headers from body
4. **Body**: The actual content/data

Example structure:
```
HTTP/1.1 200 OK
Content-Type: application/json
Content-Length: 123

{"message": "Success"}
```

## HTTP and HTTPS

- **HTTP**: Unencrypted communication (port 80)
- **HTTPS**: Encrypted with SSL/TLS (port 443)

HTTPS provides:
- **Confidentiality**: Data is encrypted
- **Integrity**: Data cannot be modified in transit
- **Authentication**: Verifies the server's identity

Let's verify we're using HTTPS:

```{hurl}
#| echo: true
#| output: true

GET https://httpbin.io/get
```

In the response, check the `url` field - it shows `https://`, confirming the secure connection.

## The TCP/IP Connection

Before HTTP communication can begin, a TCP connection must be established:

1. **DNS Resolution**: Convert hostname to IP address
2. **TCP Handshake**: Three-way handshake to establish connection
3. **TLS Handshake**: (for HTTPS) Establish encrypted channel
4. **HTTP Request/Response**: Exchange messages
5. **Connection Close**: (or kept alive for subsequent requests)

```{mermaid}
sequenceDiagram
    participant C as Client
    participant S as Server
    participant DNS as DNS Server

    C->>DNS: DNS Query: httpbin.io
    DNS->>C: IP Address: 54.166.163.67

    Note over C,S: TCP 3-Way Handshake
    C->>S: SYN
    S->>C: SYN-ACK
    C->>S: ACK

    Note over C,S: TLS Handshake (HTTPS)
    C->>S: ClientHello
    S->>C: ServerHello + Certificate
    C->>S: Key Exchange
    S->>C: Finished

    Note over C,S: HTTP Exchange
    C->>S: HTTP Request
    S->>C: HTTP Response

    Note over C,S: Connection Close or Keep-Alive
```

## HTTP is Stateless

HTTP itself doesn't remember previous requests. Each request is independent:

```{hurl}
#| echo: true
#| output: true

GET https://httpbin.io/get
X-Request-ID: request-1
```

```{hurl}
#| echo: true
#| output: true

GET https://httpbin.io/get
X-Request-ID: request-2
```

Notice each response is independent - the server doesn't "remember" the first request. Statefulness is typically added through:

- Cookies
- Session tokens
- JWT tokens
- URL parameters

```{mermaid}
graph TD
    A[HTTP is Stateless] --> B[Each request is independent]
    B --> C[Server doesn't remember previous requests]

    D[Adding State] --> E[Cookies]
    D --> F[Session Tokens]
    D --> G[JWT Tokens]
    D --> H[URL Parameters]

    E --> I[Client stores, sends with each request]
    F --> I
    G --> I
    H --> I

    style A fill:#ffcccc
    style D fill:#ccffcc
```

## Testing Connectivity

Let's verify basic connectivity and inspect what data is sent:

```{hurl}
#| echo: true
#| output: true

GET https://httpbin.io/anything
```

The `/anything` endpoint returns everything about your request, which is great for debugging.

## Key Takeaways

- HTTP is a stateless, text-based protocol for client-server communication
- URLs contain the scheme, hostname, path, and optional query parameters
- Requests have a method, path, headers, and optional body
- Responses have a status code, headers, and optional body
- HTTPS adds encryption via SSL/TLS
- Each request is independent unless state is explicitly maintained

## Practice Exercises

Try these on your own:

1. Make a request to `https://httpbin.io/user-agent` and observe what's returned
2. Make a request with multiple query parameters
3. Add a custom header to your request and verify it appears in the response

## Next Steps

Now that you understand HTTP basics, let's explore the different HTTP methods in [Chapter 2: HTTP Methods](02-http-methods.qmd).

---

## RFC References

This chapter covers concepts from the following RFCs:

::: {.callout-note icon=false}
### Core HTTP Specifications

- **[RFC 9110](https://www.rfc-editor.org/rfc/rfc9110.html)** - HTTP Semantics (replaces RFC 7230-7235)
  - Section 2: [Conformance](https://www.rfc-editor.org/rfc/rfc9110.html#section-2)
  - Section 3: [Terminology and Core Concepts](https://www.rfc-editor.org/rfc/rfc9110.html#section-3)
  - Section 6: [Message Abstraction](https://www.rfc-editor.org/rfc/rfc9110.html#section-6)
- **[RFC 9112](https://www.rfc-editor.org/rfc/rfc9112.html)** - HTTP/1.1
  - Section 2: [Message Format](https://www.rfc-editor.org/rfc/rfc9112.html#section-2)
- **[RFC 3986](https://www.rfc-editor.org/rfc/rfc3986.html)** - URI Generic Syntax
  - Section 3: [Syntax Components](https://www.rfc-editor.org/rfc/rfc3986.html#section-3)
:::
